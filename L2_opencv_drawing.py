import numpy as np
import cv2

# 定義數位影像(全黑)
img = np.zeros( [ 400, 500, 3 ], dtype = 'uint8' )

# 直線 (輸入影像,第一個點座標,第二個點座標,顏色[,直線厚度[,線的型態[,點座標的小數位數]]])
cv2.line( img, ( 50, 50 ), ( 150, 150 ), ( 255, 0, 0 ), 2, cv2.LINE_AA, 0 )
#線的型態：8:8相連、4:4相連、LIN_AA:反混疊Anti-Aliased

# 矩形 (輸入影像,第一個點座標,第二個點座標,顏色[,矩形厚度[,線的型態[,點座標的小數位數]]])
cv2.rectangle( img, ( 200, 50 ), ( 300, 150 ), ( 0, 255, 0 ), -1 )
#矩形厚度 若為負值則為填滿矩形內部

# 圓形 (輸入影像,圓心座標,半徑,顏色[,圓形厚度[,線的型態[,點座標的小數位數]]])
cv2.circle( img, ( 400, 100 ), 50, ( 0, 0, 255 ), -1 )
#圓形厚度 若為負值則為填滿圓形內部

# 橢圓形 (輸入影像,圓心座標,主軸大小的一半,旋轉角度,開始角度,結束角度,顏色[,橢圓形厚度[,線的型態[,點座標的小數位數]]])
cv2.ellipse( img, ( 100, 300 ), ( 60, 40 ), 135, 0, 360, ( 255, 255, 0 ), 1 )
#橢圓形厚度 若為負值則為填滿橢圓形內部

# 多邊形 (輸入影像,多邊形的頂點座標陣列,是否為封閉多邊形,顏色[,多邊形厚度[,線的型態[,點座標中的小數位數]]])
points = np.array( [ [ 200, 220 ], [ 220, 350 ], [ 280, 320 ], [ 300, 250 ] ] )
cv2.polylines( img, [points], True, ( 255, 0, 255 ) )
#是否為封閉多邊形 若為True 則繪製從最後點座標到最初點座標

# 填滿多邊形 (輸入影像,多邊形的頂點座標陣列,是否為封閉多邊形,顏色[,多邊形厚度[,線的型態[,點座標中的小數位數]]])
points = np.array( [ [ 400, 220 ], [ 350, 300 ], [ 420, 350 ], [ 450, 250 ] ] )
cv2.fillPoly( img, [points], ( 255, 255, 0 ) )
#是否為封閉多邊形 若為True 則繪製從最後點座標到最初點座標

# 顯示數位影像
cv2.imshow( "Example", img )
cv2.waitKey( 0 )
